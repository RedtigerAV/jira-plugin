/* tslint:disable */

/**
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ChangedWorklogsModel } from '../model/changedWorklogs';
import { PageOfWorklogsModel } from '../model/pageOfWorklogs';
import { WorklogIdsRequestBeanModel } from '../model/worklogIdsRequestBean';
import { WorklogModel } from '../model/worklog';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class IssueWorklogsService {

    protected basePath = 'https://timgo.atlassian.net';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add worklog
     * Adds a worklog to an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Work on issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key the issue.
     * @param requestBody 
     * @param notifyUsers Whether users watching the issue are notified by email.
     * @param adjustEstimate Defines how to update the issue\&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;manual&#x60; Reduces the estimate by amount specified in &#x60;reduceBy&#x60;.  *  &#x60;auto&#x60; Reduces the estimate by the value of &#x60;timeSpent&#x60; in the worklog.
     * @param newEstimate The value to set as the issue\&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;.
     * @param reduceBy The amount to reduce the issue\&#39;s remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;manual&#x60;.
     * @param expand Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts &#x60;properties&#x60;, which returns worklog properties.
     * @param overrideEditableFlag Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Only connect app users with admin scope permission can use this flag.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addWorklog(issueIdOrKey: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, reduceBy?: string, expand?: string, overrideEditableFlag?: boolean, observe?: 'body', reportProgress?: boolean): Observable<WorklogModel>;
    public addWorklog(issueIdOrKey: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, reduceBy?: string, expand?: string, overrideEditableFlag?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorklogModel>>;
    public addWorklog(issueIdOrKey: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, reduceBy?: string, expand?: string, overrideEditableFlag?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorklogModel>>;
    public addWorklog(issueIdOrKey: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, reduceBy?: string, expand?: string, overrideEditableFlag?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (issueIdOrKey === null || issueIdOrKey === undefined) {
            throw new Error('Required parameter issueIdOrKey was null or undefined when calling addWorklog.');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new Error('Required parameter requestBody was null or undefined when calling addWorklog.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (notifyUsers !== undefined && notifyUsers !== null) {
            queryParameters = queryParameters.set('notifyUsers', <any>notifyUsers);
        }
        if (adjustEstimate !== undefined && adjustEstimate !== null) {
            queryParameters = queryParameters.set('adjustEstimate', <any>adjustEstimate);
        }
        if (newEstimate !== undefined && newEstimate !== null) {
            queryParameters = queryParameters.set('newEstimate', <any>newEstimate);
        }
        if (reduceBy !== undefined && reduceBy !== null) {
            queryParameters = queryParameters.set('reduceBy', <any>reduceBy);
        }
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }
        if (overrideEditableFlag !== undefined && overrideEditableFlag !== null) {
            queryParameters = queryParameters.set('overrideEditableFlag', <any>overrideEditableFlag);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<WorklogModel>(`${this.configuration.basePath}/rest/api/3/issue/${encodeURIComponent(String(issueIdOrKey))}/worklog`,
            requestBody,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete worklog
     * Deletes a worklog from an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog or *Delete own worklogs* to delete worklogs created by the user,  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the worklog.
     * @param notifyUsers Whether users watching the issue are notified by email.
     * @param adjustEstimate Defines how to update the issue\&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;manual&#x60; Increases the estimate by amount specified in &#x60;increaseBy&#x60;.  *  &#x60;auto&#x60; Reduces the estimate by the value of &#x60;timeSpent&#x60; in the worklog.
     * @param newEstimate The value to set as the issue\&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;.
     * @param increaseBy The amount to increase the issue\&#39;s remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;manual&#x60;.
     * @param overrideEditableFlag Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Only connect app users with admin permissions can use this flag.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteWorklog(issueIdOrKey: string, id: string, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, increaseBy?: string, overrideEditableFlag?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteWorklog(issueIdOrKey: string, id: string, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, increaseBy?: string, overrideEditableFlag?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteWorklog(issueIdOrKey: string, id: string, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, increaseBy?: string, overrideEditableFlag?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteWorklog(issueIdOrKey: string, id: string, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, increaseBy?: string, overrideEditableFlag?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (issueIdOrKey === null || issueIdOrKey === undefined) {
            throw new Error('Required parameter issueIdOrKey was null or undefined when calling deleteWorklog.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteWorklog.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (notifyUsers !== undefined && notifyUsers !== null) {
            queryParameters = queryParameters.set('notifyUsers', <any>notifyUsers);
        }
        if (adjustEstimate !== undefined && adjustEstimate !== null) {
            queryParameters = queryParameters.set('adjustEstimate', <any>adjustEstimate);
        }
        if (newEstimate !== undefined && newEstimate !== null) {
            queryParameters = queryParameters.set('newEstimate', <any>newEstimate);
        }
        if (increaseBy !== undefined && increaseBy !== null) {
            queryParameters = queryParameters.set('increaseBy', <any>increaseBy);
        }
        if (overrideEditableFlag !== undefined && overrideEditableFlag !== null) {
            queryParameters = queryParameters.set('overrideEditableFlag', <any>overrideEditableFlag);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.configuration.basePath}/rest/api/3/issue/${encodeURIComponent(String(issueIdOrKey))}/worklog/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get IDs of deleted worklogs
     * Returns a list of IDs and delete timestamps for worklogs deleted after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, &#x60;until&#x60; indicates the timestamp of the youngest item on the page. Also, &#x60;nextPage&#x60; provides the URL for the next page of worklogs. The &#x60;lastPage&#x60; parameter is set to true on the last page of worklogs.  This resource does not return worklogs deleted during the minute preceding the request.  **[Permissions](#permissions) required:** Permission to access Jira.
     * @param since The date and time, in UNIX timestamp format, after which deleted worklogs are returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIdsOfWorklogsDeletedSince(since?: number, observe?: 'body', reportProgress?: boolean): Observable<ChangedWorklogsModel>;
    public getIdsOfWorklogsDeletedSince(since?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChangedWorklogsModel>>;
    public getIdsOfWorklogsDeletedSince(since?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChangedWorklogsModel>>;
    public getIdsOfWorklogsDeletedSince(since?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (since !== undefined && since !== null) {
            queryParameters = queryParameters.set('since', <any>since);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ChangedWorklogsModel>(`${this.configuration.basePath}/rest/api/3/worklog/deleted`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get IDs of updated worklogs
     * Returns a list of IDs and update timestamps for worklogs updated after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, &#x60;until&#x60; indicates the timestamp of the youngest item on the page. Also, &#x60;nextPage&#x60; provides the URL for the next page of worklogs. The &#x60;lastPage&#x60; parameter is set to true on the last page of worklogs.  This resource does not return worklogs updated during the minute preceding the request.  **[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.
     * @param since The date and time, in UNIX timestamp format, after which updated worklogs are returned.
     * @param expand Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60; that returns the properties of each worklog.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIdsOfWorklogsModifiedSince(since?: number, expand?: string, observe?: 'body', reportProgress?: boolean): Observable<ChangedWorklogsModel>;
    public getIdsOfWorklogsModifiedSince(since?: number, expand?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChangedWorklogsModel>>;
    public getIdsOfWorklogsModifiedSince(since?: number, expand?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChangedWorklogsModel>>;
    public getIdsOfWorklogsModifiedSince(since?: number, expand?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (since !== undefined && since !== null) {
            queryParameters = queryParameters.set('since', <any>since);
        }
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ChangedWorklogsModel>(`${this.configuration.basePath}/rest/api/3/worklog/updated`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get issue worklogs
     * Returns worklogs for an issue, starting from the oldest worklog or from the worklog started on or after a date and time.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Workloads are only returned where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key of the issue.
     * @param startAt The index of the first item to return in a page of results (page offset).
     * @param maxResults The maximum number of items to return per page.
     * @param startedAfter The worklog start date and time, in UNIX timestamp format, after which worklogs are returned.
     * @param expand Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts&#x60;properties&#x60;, which returns worklog properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIssueWorklog(issueIdOrKey: string, startAt?: number, maxResults?: number, startedAfter?: number, expand?: string, observe?: 'body', reportProgress?: boolean): Observable<PageOfWorklogsModel>;
    public getIssueWorklog(issueIdOrKey: string, startAt?: number, maxResults?: number, startedAfter?: number, expand?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfWorklogsModel>>;
    public getIssueWorklog(issueIdOrKey: string, startAt?: number, maxResults?: number, startedAfter?: number, expand?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfWorklogsModel>>;
    public getIssueWorklog(issueIdOrKey: string, startAt?: number, maxResults?: number, startedAfter?: number, expand?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (issueIdOrKey === null || issueIdOrKey === undefined) {
            throw new Error('Required parameter issueIdOrKey was null or undefined when calling getIssueWorklog.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startAt !== undefined && startAt !== null) {
            queryParameters = queryParameters.set('startAt', <any>startAt);
        }
        if (maxResults !== undefined && maxResults !== null) {
            queryParameters = queryParameters.set('maxResults', <any>maxResults);
        }
        if (startedAfter !== undefined && startedAfter !== null) {
            queryParameters = queryParameters.set('startedAfter', <any>startedAfter);
        }
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfWorklogsModel>(`${this.configuration.basePath}/rest/api/3/issue/${encodeURIComponent(String(issueIdOrKey))}/worklog`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get worklog
     * Returns a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the worklog.
     * @param expand Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts  &#x60;properties&#x60;, which returns worklog properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorklog(issueIdOrKey: string, id: string, expand?: string, observe?: 'body', reportProgress?: boolean): Observable<WorklogModel>;
    public getWorklog(issueIdOrKey: string, id: string, expand?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorklogModel>>;
    public getWorklog(issueIdOrKey: string, id: string, expand?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorklogModel>>;
    public getWorklog(issueIdOrKey: string, id: string, expand?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (issueIdOrKey === null || issueIdOrKey === undefined) {
            throw new Error('Required parameter issueIdOrKey was null or undefined when calling getWorklog.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getWorklog.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<WorklogModel>(`${this.configuration.basePath}/rest/api/3/issue/${encodeURIComponent(String(issueIdOrKey))}/worklog/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get worklogs
     * Returns worklog details for a list of worklog IDs.  The returned list of worklogs is limited to 1000 items.  **[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.
     * @param worklogIdsRequestBeanModel A JSON object containing a list of worklog IDs.
     * @param expand Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60; that returns the properties of each worklog.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getWorklogsForIds(worklogIdsRequestBeanModel: WorklogIdsRequestBeanModel, expand?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<WorklogModel>>;
    public getWorklogsForIds(worklogIdsRequestBeanModel: WorklogIdsRequestBeanModel, expand?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<WorklogModel>>>;
    public getWorklogsForIds(worklogIdsRequestBeanModel: WorklogIdsRequestBeanModel, expand?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<WorklogModel>>>;
    public getWorklogsForIds(worklogIdsRequestBeanModel: WorklogIdsRequestBeanModel, expand?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (worklogIdsRequestBeanModel === null || worklogIdsRequestBeanModel === undefined) {
            throw new Error('Required parameter worklogIdsRequestBeanModel was null or undefined when calling getWorklogsForIds.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<WorklogModel>>(`${this.configuration.basePath}/rest/api/3/worklog/list`,
            worklogIdsRequestBeanModel,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update worklog
     * Updates a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Edit all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to update any worklog or *Edit own worklogs* to update worklogs created by the user.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key the issue.
     * @param id The ID of the worklog.
     * @param requestBody 
     * @param notifyUsers Whether users watching the issue are notified by email.
     * @param adjustEstimate Defines how to update the issue\&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;auto&#x60; Updates the estimate by the difference between the original and updated value of &#x60;timeSpent&#x60; or &#x60;timeSpentSeconds&#x60;.
     * @param newEstimate The value to set as the issue\&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;.
     * @param expand Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60;, which returns worklog properties.
     * @param overrideEditableFlag Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Only connect app users with admin permissions can use this flag.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateWorklog(issueIdOrKey: string, id: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, expand?: string, overrideEditableFlag?: boolean, observe?: 'body', reportProgress?: boolean): Observable<WorklogModel>;
    public updateWorklog(issueIdOrKey: string, id: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, expand?: string, overrideEditableFlag?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorklogModel>>;
    public updateWorklog(issueIdOrKey: string, id: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, expand?: string, overrideEditableFlag?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorklogModel>>;
    public updateWorklog(issueIdOrKey: string, id: string, requestBody: { [key: string]: object; }, notifyUsers?: boolean, adjustEstimate?: 'new' | 'leave' | 'manual' | 'auto', newEstimate?: string, expand?: string, overrideEditableFlag?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (issueIdOrKey === null || issueIdOrKey === undefined) {
            throw new Error('Required parameter issueIdOrKey was null or undefined when calling updateWorklog.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateWorklog.');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new Error('Required parameter requestBody was null or undefined when calling updateWorklog.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (notifyUsers !== undefined && notifyUsers !== null) {
            queryParameters = queryParameters.set('notifyUsers', <any>notifyUsers);
        }
        if (adjustEstimate !== undefined && adjustEstimate !== null) {
            queryParameters = queryParameters.set('adjustEstimate', <any>adjustEstimate);
        }
        if (newEstimate !== undefined && newEstimate !== null) {
            queryParameters = queryParameters.set('newEstimate', <any>newEstimate);
        }
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }
        if (overrideEditableFlag !== undefined && overrideEditableFlag !== null) {
            queryParameters = queryParameters.set('overrideEditableFlag', <any>overrideEditableFlag);
        }

        let headers = this.defaultHeaders;

        // authentication (OAuth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<WorklogModel>(`${this.configuration.basePath}/rest/api/3/issue/${encodeURIComponent(String(issueIdOrKey))}/worklog/${encodeURIComponent(String(id))}`,
            requestBody,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
